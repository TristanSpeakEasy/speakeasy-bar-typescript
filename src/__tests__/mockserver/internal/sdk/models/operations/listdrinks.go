// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

type ListDrinksSecurity struct {
	APIKey *string `security:"scheme,type=apiKey,subtype=header,name=Authorization"`
}

func (o *ListDrinksSecurity) GetAPIKey() *string {
	if o == nil {
		return nil
	}
	return o.APIKey
}

type ListDrinksRequest struct {
	// The type of drink to filter by. If not provided all drinks will be returned.
	Type *components.DrinkType `queryParam:"style=form,explode=true,name=type"`
}

func (o *ListDrinksRequest) GetType() *components.DrinkType {
	if o == nil {
		return nil
	}
	return o.Type
}

type ResponseBodyType string

const (
	ResponseBodyTypeUnauthenticated ResponseBodyType = "unauthenticated"
	ResponseBodyTypeAuthenticated   ResponseBodyType = "authenticated"
)

type ResponseBody struct {
	Drink       *components.Drink       `queryParam:"inline"`
	PublicDrink *components.PublicDrink `queryParam:"inline"`

	Type ResponseBodyType
}

func CreateResponseBodyUnauthenticated(unauthenticated components.PublicDrink) ResponseBody {
	typ := ResponseBodyTypeUnauthenticated

	typStr := components.PublicDrinkDataLevel(typ)
	unauthenticated.DataLevel = &typStr

	return ResponseBody{
		PublicDrink: &unauthenticated,
		Type:        typ,
	}
}

func CreateResponseBodyAuthenticated(authenticated components.Drink) ResponseBody {
	typ := ResponseBodyTypeAuthenticated

	typStr := components.DrinkDataLevel(typ)
	authenticated.DataLevel = &typStr

	return ResponseBody{
		Drink: &authenticated,
		Type:  typ,
	}
}

func (u *ResponseBody) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		DataLevel string `json:"dataLevel"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.DataLevel {
	case "unauthenticated":
		publicDrink := new(components.PublicDrink)
		if err := utils.UnmarshalJSON(data, &publicDrink, "", true, false); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (DataLevel == unauthenticated) type components.PublicDrink within ResponseBody: %w", string(data), err)
		}

		u.PublicDrink = publicDrink
		u.Type = ResponseBodyTypeUnauthenticated
		return nil
	case "authenticated":
		drink := new(components.Drink)
		if err := utils.UnmarshalJSON(data, &drink, "", true, false); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (DataLevel == authenticated) type components.Drink within ResponseBody: %w", string(data), err)
		}

		u.Drink = drink
		u.Type = ResponseBodyTypeAuthenticated
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ResponseBody", string(data))
}

func (u ResponseBody) MarshalJSON() ([]byte, error) {
	if u.Drink != nil {
		return utils.MarshalJSON(u.Drink, "", true)
	}

	if u.PublicDrink != nil {
		return utils.MarshalJSON(u.PublicDrink, "", true)
	}

	return nil, errors.New("could not marshal union type ResponseBody: all fields are null")
}

type ListDrinksResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// A list of drinks.
	ResponseBodies []ResponseBody
	// An unknown error occurred interacting with the API.
	Error *components.Error
}

func (o *ListDrinksResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *ListDrinksResponse) GetResponseBodies() []ResponseBody {
	if o == nil {
		return nil
	}
	return o.ResponseBodies
}

func (o *ListDrinksResponse) GetError() *components.Error {
	if o == nil {
		return nil
	}
	return o.Error
}
