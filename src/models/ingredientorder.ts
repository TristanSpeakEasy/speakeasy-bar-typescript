/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const IngredientOrderOrderType = {
  Ingredient: "ingredient",
} as const;
export type IngredientOrderOrderType = ClosedEnum<
  typeof IngredientOrderOrderType
>;

/**
 * The status of the order.
 */
export const IngredientOrderStatus = {
  Pending: "pending",
  Processing: "processing",
  Complete: "complete",
} as const;
/**
 * The status of the order.
 */
export type IngredientOrderStatus = ClosedEnum<typeof IngredientOrderStatus>;

/**
 * An order for a drink or ingredient.
 */
export type IngredientOrder = {
  orderType: IngredientOrderOrderType;
  /**
   * The product code of the drink or ingredient.
   */
  productCode: string;
  /**
   * The number of units of the drink or ingredient to order.
   */
  quantity: number;
  /**
   * The status of the order.
   */
  status: IngredientOrderStatus;
  /**
   * The address to deliver the ingredient to.
   */
  deliveryAddress?: string | undefined;
};

/**
 * An order for a drink or ingredient.
 */
export type IngredientOrderInput = {
  orderType: IngredientOrderOrderType;
  /**
   * The product code of the drink or ingredient.
   */
  productCode: string;
  /**
   * The number of units of the drink or ingredient to order.
   */
  quantity: number;
  /**
   * The address to deliver the ingredient to.
   */
  deliveryAddress?: string | undefined;
};

/** @internal */
export const IngredientOrderOrderType$inboundSchema: z.ZodNativeEnum<
  typeof IngredientOrderOrderType
> = z.nativeEnum(IngredientOrderOrderType);

/** @internal */
export const IngredientOrderOrderType$outboundSchema: z.ZodNativeEnum<
  typeof IngredientOrderOrderType
> = IngredientOrderOrderType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IngredientOrderOrderType$ {
  /** @deprecated use `IngredientOrderOrderType$inboundSchema` instead. */
  export const inboundSchema = IngredientOrderOrderType$inboundSchema;
  /** @deprecated use `IngredientOrderOrderType$outboundSchema` instead. */
  export const outboundSchema = IngredientOrderOrderType$outboundSchema;
}

/** @internal */
export const IngredientOrderStatus$inboundSchema: z.ZodNativeEnum<
  typeof IngredientOrderStatus
> = z.nativeEnum(IngredientOrderStatus);

/** @internal */
export const IngredientOrderStatus$outboundSchema: z.ZodNativeEnum<
  typeof IngredientOrderStatus
> = IngredientOrderStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IngredientOrderStatus$ {
  /** @deprecated use `IngredientOrderStatus$inboundSchema` instead. */
  export const inboundSchema = IngredientOrderStatus$inboundSchema;
  /** @deprecated use `IngredientOrderStatus$outboundSchema` instead. */
  export const outboundSchema = IngredientOrderStatus$outboundSchema;
}

/** @internal */
export const IngredientOrder$inboundSchema: z.ZodType<
  IngredientOrder,
  z.ZodTypeDef,
  unknown
> = z.object({
  orderType: IngredientOrderOrderType$inboundSchema,
  productCode: z.string(),
  quantity: z.number().int(),
  status: IngredientOrderStatus$inboundSchema,
  deliveryAddress: z.string().optional(),
});

/** @internal */
export type IngredientOrder$Outbound = {
  orderType: string;
  productCode: string;
  quantity: number;
  status: string;
  deliveryAddress?: string | undefined;
};

/** @internal */
export const IngredientOrder$outboundSchema: z.ZodType<
  IngredientOrder$Outbound,
  z.ZodTypeDef,
  IngredientOrder
> = z.object({
  orderType: IngredientOrderOrderType$outboundSchema,
  productCode: z.string(),
  quantity: z.number().int(),
  status: IngredientOrderStatus$outboundSchema,
  deliveryAddress: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IngredientOrder$ {
  /** @deprecated use `IngredientOrder$inboundSchema` instead. */
  export const inboundSchema = IngredientOrder$inboundSchema;
  /** @deprecated use `IngredientOrder$outboundSchema` instead. */
  export const outboundSchema = IngredientOrder$outboundSchema;
  /** @deprecated use `IngredientOrder$Outbound` instead. */
  export type Outbound = IngredientOrder$Outbound;
}

export function ingredientOrderToJSON(
  ingredientOrder: IngredientOrder,
): string {
  return JSON.stringify(IngredientOrder$outboundSchema.parse(ingredientOrder));
}

export function ingredientOrderFromJSON(
  jsonString: string,
): SafeParseResult<IngredientOrder, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IngredientOrder$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IngredientOrder' from JSON`,
  );
}

/** @internal */
export const IngredientOrderInput$inboundSchema: z.ZodType<
  IngredientOrderInput,
  z.ZodTypeDef,
  unknown
> = z.object({
  orderType: IngredientOrderOrderType$inboundSchema,
  productCode: z.string(),
  quantity: z.number().int(),
  deliveryAddress: z.string().optional(),
});

/** @internal */
export type IngredientOrderInput$Outbound = {
  orderType: string;
  productCode: string;
  quantity: number;
  deliveryAddress?: string | undefined;
};

/** @internal */
export const IngredientOrderInput$outboundSchema: z.ZodType<
  IngredientOrderInput$Outbound,
  z.ZodTypeDef,
  IngredientOrderInput
> = z.object({
  orderType: IngredientOrderOrderType$outboundSchema,
  productCode: z.string(),
  quantity: z.number().int(),
  deliveryAddress: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IngredientOrderInput$ {
  /** @deprecated use `IngredientOrderInput$inboundSchema` instead. */
  export const inboundSchema = IngredientOrderInput$inboundSchema;
  /** @deprecated use `IngredientOrderInput$outboundSchema` instead. */
  export const outboundSchema = IngredientOrderInput$outboundSchema;
  /** @deprecated use `IngredientOrderInput$Outbound` instead. */
  export type Outbound = IngredientOrderInput$Outbound;
}

export function ingredientOrderInputToJSON(
  ingredientOrderInput: IngredientOrderInput,
): string {
  return JSON.stringify(
    IngredientOrderInput$outboundSchema.parse(ingredientOrderInput),
  );
}

export function ingredientOrderInputFromJSON(
  jsonString: string,
): SafeParseResult<IngredientOrderInput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IngredientOrderInput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IngredientOrderInput' from JSON`,
  );
}
